# 价格模型重构：代码分类分析

## ✅ 可以保留并直接修改的文件

### 1. **Core数学模型层** - 保留并复用

#### `BrownianBridge.cs` ✅ **完美,只需改调用方式**
- **现状**: 代码质量很高,公式已经正确实现了引力+噪声
- **改动**: 
  - ✅ **保留不变!** 代码已经是完美的
  - 只需改变**调用时机**: 从"逐帧调用"改为"预生成时批量调用"
- **新用法**:
  ```csharp
  // 旧: 每帧在Update()里调用
  // 新: 在DayStart时一次性生成整天的价格数组
  for (int i = 0; i < 120; i++) // 120个10分钟区间
  {
      shadowPrices[i] = BrownianBridge.CalculateNextTickPrice(...);
  }
  ```

#### `GBM.cs` ✅ **完美,只需改调用方式**
- **现状**: 均值回归GBM实现正确
- **改动**: 
  - ✅ **保留不变!**
  - 只需改**调用时机**: 从"每日更新"改为"季度开始时批量生成"
- **新用法**:
  ```csharp
  // 季度开始时预生成整个季度的每日收盘价
  for (int day = 0; day < 28; day++)
  {
      dailyPrices[day] = GBM.CalculateNextPrice(...);
  }
  ```

#### `StatisticsUtils.cs` ✅ **无需改动**
- 工具类,继续使用

---

### 2. **时间系统** - 保留并增强

#### `StardewTimeProvider.cs` ✅ **保留,添加新方法**
- **现状**: 已经正确实现了时间转换和进度计算
- **需要添加**:
  ```csharp
  // 新增: 获取当前10分钟区间的微观进度
  public double GetSubIntervalProgress()
  {
      // 使用 Game1.gameTimeInterval 和 
      // Game1.realMilliSecondsPerGameTenMinutes
      float progress = (float)Game1.gameTimeInterval / 
                       (float)Game1.realMilliSecondsPerGameTenMinutes;
      return Math.Clamp(progress, 0.0, 1.0);
  }
  
  // 新增: 获取当前是第几个10分钟区间
  public int GetCurrentTimeIndex()
  {
      int minutes = ToMinutes(Game1.timeOfDay);
      return minutes / 10; // 每10分钟一个索引
  }
  ```

#### `MixedTimeClock.cs` ✅ **保留**
- 已经封装了时间逻辑,继续使用

---

### 3. **订单簿系统** - 保留并扩展

#### `OrderBook.cs` ✅ **保留,添加虚拟流量处理**
- **现状**: 已经有完整的限价单管理和成交逻辑
- **需要添加**:
  ```csharp
  // 新增: 处理虚拟订单流(用于势能驱动)
  public decimal ProcessVirtualOrderFlow(
      bool isBuy,           // 买/卖方向
      int virtualQuantity,  // 虚拟流量数量
      out int consumedQty)  // 输出:被玩家墙消耗的数量
  {
      // 逻辑:
      // 1. 遍历对手方挂单
      // 2. 如果碰到玩家限价单,消耗虚拟流量
      // 3. 如果虚拟流量耗尽,价格停止
      // 4. 返回最终成交价格
  }
  ```

#### `OrderBookManager.cs` ✅ **保留**
- 管理多个订单簿的逻辑很好,继续使用

---

### 4. **配置系统** - 保留并扩展

#### `MarketRules.cs` ✅ **保留,添加NPC参数**
- **需要添加**:
  ```csharp
  public class MarketMicrostructure
  {
      // 已有的参数保留...
      
      // 新增: NPC行为参数
      public NPCAgentConfig NPCAgents { get; set; }
  }
  
  public class NPCAgentConfig
  {
      public SmartMoneyConfig SmartMoney { get; set; }
      public TrendFollowerConfig TrendFollower { get; set; }
      public FOMOConfig FOMO { get; set; }
  }
  
  public class SmartMoneyConfig
  {
      public double k_smart { get; set; } = 0.05;
  }
  // ... 其他NPC配置
  ```

#### `market_rules.json` ✅ **扩展**
- 添加新的配置节点

---

## 🔄 需要重构的文件

### 1. **核心价格更新逻辑** - 需要重大重构

#### `PriceEngine.cs` ⚠️ **需要重构**
**现状问题**:
- 当前是"逐帧计算"模式: `UpdatePrice()`每帧调用一次
- 没有预生成逻辑

**重构方案**:
```csharp
public class PriceEngine
{
    // 保留现有的构造函数和依赖注入
    
    // ❌ 删除: UpdatePrice() - 不再逐帧计算
    
    // ✅ 新增: 预生成整个季度的影子价格
    public float[] GenerateSeasonalShadowPrices(
        CommodityFutures futures,
        Season season)
    {
        // 1. 使用 GBM 生成每日收盘价 (28天)
        // 2. 对每一天,使用 BrownianBridge 生成日内轨迹 (120个点)
        // 3. 返回 28 * 120 = 3360 个价格点的数组
    }
    
    // ✅ 新增: 获取当前时刻的影子价格(带插值和噪声)
    public double GetCurrentShadowPrice(
        float[] shadowPrices,
        int currentTimeIndex,
        double subProgress)  // 0.0-1.0, 10分钟内的进度
    {
        // 1. 线性插值
        float basePrice = Lerp(
            shadowPrices[currentTimeIndex],
            shadowPrices[currentTimeIndex + 1],
            subProgress
        );
        
        // 2. 叠加噪声(如果配置启用)
        if (_rules.MicroVolatility.Enabled)
        {
            double noise = GenerateNoise(...);
            return basePrice + noise;
        }
        
        return basePrice;
    }
    
    // ✅ 保留: CalculateFuturesPrice() - 持有成本模型
}
```

---

#### `MarketPriceUpdater.cs` ⚠️ **需要大幅简化**
**现状问题**:
- 679行代码,逻辑过于复杂
- 混合了价格计算、新闻、熔断、虚拟流量等多个职责

**重构方案**:
```csharp
public class MarketPriceUpdater
{
    // ✅ 保留: OnNewDay() - 但简化逻辑
    public void OnNewDay()
    {
        foreach (var futures in _instruments)
        {
            // 1. 调用 PriceEngine.GenerateSeasonalShadowPrices()
            // 2. 存储到 futures.ShadowPrices
            // 3. 重置订单簿
        }
    }
    
    // ✅ 简化: Update() - 核心逻辑变简单
    public void Update()
    {
        foreach (var futures in _instruments)
        {
            // 1. 获取影子价格
            double shadowPrice = _priceEngine.GetCurrentShadowPrice(...);
            
            // 2. 获取撮合价格
            double matchPrice = _orderBooks[futures.Symbol].LastPrice;
            
            // 3. 计算势能差
            double gap = shadowPrice - matchPrice;
            
            // 4. 如果有势能差,生成虚拟流量
            if (Math.Abs(gap) > 0.01)
            {
                ProcessVirtualFlow(futures, gap);
            }
        }
    }
    
    // ✅ 保留但简化: ProcessVirtualFlow()
    // - 移除复杂的Impact累加逻辑
    // - 直接调用 OrderBook.ProcessVirtualOrderFlow()
    
    // ✅ 保留: 新闻系统相关方法
    // ✅ 保留: 熔断机制
}
```

---

#### `ImpactService.cs` ⚠️ **需要重构并重命名**
**现状问题**:
- 当前实现了 `I(t)` 累加和衰减逻辑
- 但在新架构中,这个逻辑被"聪明钱NPC"取代了

**重构方案**:
1. **方案A: 重命名并重构为 `NPCAgentManager.cs`**
   ```csharp
   public class NPCAgentManager
   {
       // ❌ 删除: UpdateImpact() 的衰减逻辑
       
       // ✅ 保留并重构: CalculateSmartMoney()
       public int CalculateSmartMoneyFlow(
           double shadowPrice,
           double matchPrice,
           double k_smart)
       {
           double gap = shadowPrice - matchPrice;
           return (int)(gap * k_smart * _volumeCoefficient);
       }
       
       // ✅ 保留并重构: CalculateTrendFollower()
       // ✅ 保留并重构: CalculateFOMO()
       
       // ✅ 新增: 汇总所有NPC力量
       public (int buyFlow, int sellFlow) CalculateTotalNPCFlow(...)
       {
           int smart = CalculateSmartMoneyFlow(...);
           int trend = CalculateTrendFollowerFlow(...);
           int fomo = CalculateFOMOFlow(...);
           
           int total = smart + trend + fomo;
           return total > 0 
               ? (total, 0)    // 净买入
               : (0, -total);  // 净卖出
       }
   }
   ```

2. **方案B: 保留名字,清理逻辑**
   - 如果你想保持向后兼容,可以保留 `ImpactService` 名字
   - 但删除 `I(t)` 累加逻辑,只保留NPC力量计算

---

### 2. **新增文件**

#### `ShadowPriceGenerator.cs` ✨ **需要新建**
```csharp
/// <summary>
/// 影子价格生成器
/// 负责在季度/天开始时预生成完整价格轨迹
/// </summary>
public class ShadowPriceGenerator
{
    public float[] GenerateDailyShadowPrices(
        CommodityFutures futures,
        int totalMinutes = 1200)  // 一天20小时
    {
        // 使用 BrownianBridge 生成
    }
    
    public float[] GenerateSeasonalShadowPrices(
        CommodityFutures futures,
        Season season)
    {
        // 使用 GBM + BrownianBridge 组合生成
    }
}
```

---

## 📊 总结统计

| 分类 | 文件数 | 改动程度 | 说明 |
|------|--------|----------|------|
| ✅ **无需改动** | 3 | 0% | `GBM.cs`, `BrownianBridge.cs`, `StatisticsUtils.cs` - 数学模型完美 |
| ✅ **小幅扩展** | 5 | 10-20% | `StardewTimeProvider.cs`, `OrderBook.cs`, `OrderBookManager.cs`, `MarketRules.cs`, `*.json` |
| 🔄 **中度重构** | 2 | 40-60% | `PriceEngine.cs`, `ImpactService.cs` → `NPCAgentManager.cs` |
| ⚠️ **大幅简化** | 1 | 50% | `MarketPriceUpdater.cs` - 从679行简化到300行左右 |
| ✨ **新增** | 1 | 100% | `ShadowPriceGenerator.cs` |

---

## 🎯 推荐实施顺序

### Phase 1: 准备阶段 (不影响现有功能)
1. ✅ 创建 `ShadowPriceGenerator.cs` (新文件,不影响旧代码)
2. ✅ 扩展 `StardewTimeProvider.cs` (添加新方法)
3. ✅ 扩展 `MarketRules.cs` 和 JSON配置

### Phase 2: 核心重构 (需要切换)
4. 🔄 重构 `PriceEngine.cs` (将 `UpdatePrice` 改为 `GenerateShadowPrices`)
5. 🔄 重构 `ImpactService.cs` → `NPCAgentManager.cs`

### Phase 3: 整合阶段 (联调)
6. ⚠️ 大幅简化 `MarketPriceUpdater.cs`
7. ✅ 扩展 `OrderBook.cs` 的虚拟流量处理

### Phase 4: 测试与完善
8. 🧪 单元测试
9. 🎮 游戏内测试
10. 📊 性能测试

---

## 💡 关键洞察

### 你的代码质量很高!
- ✅ **数学模型层** (`BrownianBridge`, `GBM`) 代码质量极高,无需改动
- ✅ **时间系统** 设计合理,完全支持新架构
- ✅ **订单簿系统** 已经很完善,只需添加虚拟流量处理

### 主要改动点
- 🔄 **从"逐帧计算"切换到"查表+插值"**
- 🔄 **从"公式驱动Impact"切换到"NPC博弈驱动"**
- 🔄 **简化 `MarketPriceUpdater.cs` 的复杂度**

### 风险最小化
- ✅ 核心数学模型**不需要重写**,只需改调用时机
- ✅ 可以**渐进式迁移**,新旧系统可以并存测试
- ✅ 配置文件向后兼容(添加新字段,保留旧字段)
